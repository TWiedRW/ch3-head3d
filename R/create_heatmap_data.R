#' Function to create heatmap with given stimuli values
#'
#' `generate_heatmap_data()` creates a data set that reasonably inserts known
#' stimuli value pairs into a chosen function. The function will also try to
#' balance the locations of the stimuli values across the grid coordinates.
#'
#' @import dplyr
#' @import tidyr
#' @importFrom magrittr %>%
#' @importFrom stats chisq.test
#' @importFrom stats runif
#'
#' @param x,y A vector of grid coordinates for the heatmap.
#' @param c A mixture parameter for the proportion of uniform randomness.
#' @param f A function for the true shape over the heatmap. Values will be
#'  scaled between 0 and 100.
#' @param stimuli A tibble generated by `create_stimuli()`.
#' @param num_iters Number of iterations to refine stimuli coordinates.
#' @param ... Additional arguments that are supplied to `f`.
#'
#' @returns A tibble with (X,Y) coordinates, z, and stimuli pair identifiers.
#'
#' @examples
#' generate_heatmap_data(f=\(x,y) sqrt(36-(x-mean(x))^2-(y-mean(y))^2))

generate_heatmap_data <- function(x=1:10, y=1:10, c=0.3, f, stimuli, num_iters = 20, ...){

  #Helper functions
  scale0to100 <- function(z){
    100*(z-min(z))/(max(z)-min(z))
  }

  save_iters <- list()
  for(i in 1:num_iters){
    #Create grid and calculate mixture distribution
    mixed_grid <- expand_grid(x,y) %>%
      mutate(unif = runif(nrow(.), 0, 100),
             dtn = scale0to100(f(x,y, ...)),
             f = c*unif + (1-c)*dtn)

    #Empty data frame to save results
    save_grid <- data.frame()

    #For each stimuli pair, place values into grid
    for(j in 1:nrow(stimuli)){
      val1 <- stimuli[j,1][[1]]; val2 <- stimuli[j,2][[1]]; pair_id <- stimuli[j,3][[1]]

      #Sample location of one value
      tmp1 <- mixed_grid %>%
        mutate(z = val1, diff = abs(f-val1),
               pair_id) %>%
        # filter(diff <= 15) %>%
        filter(diff == min(diff)) %>%
        slice_sample(n = 1) #to account for ties

      #Sample location of second value based off acceptable distances to first value
      tmp2 <- mixed_grid %>%
        filter(((x == tmp1$x) & (y == tmp1$y)) | (abs(x-tmp1$x) + abs(y-tmp1$y)) %in% c(3,4)) %>%
        anti_join(tmp1, by = c('x','y')) %>%
        mutate(z = val2, diff = abs(f-val2),
               pair_id) %>%
        filter(diff == min(diff)) %>%
        slice_sample(n = 1) #to account for ties

      #Save locations and values of stimuli pair, remove from available spots
      save_grid <- bind_rows(save_grid, tmp1, tmp2)
      mixed_grid <- mixed_grid %>%
        anti_join(save_grid, by = c('x', 'y'))

    }#end inner for loop

    #Join the used and unused coordinates, replacing
    full_grid <- mixed_grid %>%
      full_join(save_grid, by = c('x', 'y', 'unif', 'dtn', 'f')) %>%
      mutate(z = ifelse(is.na(z), f, z))

    #Check that placed values are not congregated along x or y axis using chi square tests
    x_coord_check <- full_grid %>%
      group_by(x) %>%
      summarize(Count = sum(!is.na(pair_id)))
    tmp_x <- chisq.test(x_coord_check$Count, simulate.p.value = T)
    y_coord_check <- full_grid %>%
      group_by(y) %>%
      summarise(Count = sum(!is.na(pair_id)))
    tmp_y <- chisq.test(y_coord_check$Count, simulate.p.value = T)

    #Save iterations into list
    save_iters[[i]] <- list(data = full_grid, chisq = mean(c(tmp_x$statistic, tmp_y$statistic)))

  }#end outer for loop

  #Find iteration with smallest average chi square statistic
  chisq <- numeric(length(save_iters))
  for(i in 1:length(chisq)){
    chisq[i] <- save_iters[[i]][['chisq']]
  }
  best_fit <- save_iters[[which.min(chisq)]][['data']] %>%
    dplyr::select(x,y,z,pair_id)
  return(best_fit)
}
